<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Save on Wednesday, September 01, 2010, 4:37 PM -->
<!-- MuClient version 4.59 -->

<!DOCTYPE muclient [
  <!ENTITY show_vnums "true" > 
  <!ENTITY show_timing "false" > 
  <!ENTITY show_completed "true" > 
  <!ENTITY show_database_mods "false" > 
  <!ENTITY show_other_areas "false" > 
  <!ENTITY show_area_exits "false" > 
  <!ENTITY show_up_down "false" > 
  <!ENTITY speedwalk_prefix "run" > 
]>

<muclient>
<plugin
   name="Aardwolf_GMCP_Mapper"
   author="Nick Gammon"
   id="b6eae87ccedd84f510b74714"
   language="Lua"
   purpose="Draws maps for GMCP MUDs"
   date_written="2010-09-01 16:37:14"
   requires="4.59"
   version="1.0"
   save_state="y"
   >

<description trim="y">
<![CDATA[

AUTOMATIC MAPPER ...  by Nick Gammon

** This plugin is a GMCP version of the ATCP mapper by Nick Gammon.
** The work here is almost all Nicks - just the GMCP specific code was 
** added by Lasher.

The window can be dragged to a new location by dragging the room name.

Your current room is always in the center with a bolder border.

LH-click on a room to speed-walk to it. RH-click on a room for options. 

LH-click on the "*" button on the upper-left corner to configure it.

** WHY DOES THE MAP CHANGE? **

The mapper draws from your room outwards - that is, it draws your room's exits
first, then the rooms leading from those rooms, and so on.

Eventually it finds an overlap, and draws a short "stub" line to indicate there
is a room there which there isn't space to draw. If you get closer to that 
room the stub will disappear and the room(s) in question will be drawn.

ACTIONS

mapper help             --> this help  (or click the "?" button on the bottom right)
mapper zoom out         --> zoom out
mapper zoom in          --> zoom in
mapper hide             --> hide map
mapper show             --> show map
mapper purgezone <area> --> remove an area from the map database

FINDING THINGS

mapper bookmarks        --> show nearby rooms that you bookmarked
mapper find <text>      --> full-text search  (eg. shop OR baker)
mapper areas            --> show path to nearby areas (zones)
mapper shop             --> show nearby shops/banks etc.
mapper train            --> show nearby trainers
mapper quest            --> show nearby quest-givers
mapper where <room>     --> show directions to a room

MOVING  

mapper goto <room>      --> walk to a room by its room number


]]>
</description>

</plugin>

<aliases>
 
  <!--  zooming aliases -->

 <alias
   match="mapper zoom out"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.zoom_out"
  >
  </alias>
  
<alias
   match="mapper zoom in"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="mapper.zoom_in"
  >
  </alias>  
    
  <!--  finding aliases -->
  
 <alias
   match="^mapper find ([\w* %d/&quot;]+)$"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="y"
  >
  
  </alias>  
    
 <alias
   match="mapper areas"
   enabled="y"
   sequence="100"
   script="map_areas"
  >
  
  </alias>  
    
 <alias
   match="^mapper shops?"
   regexp="y"
   enabled="y"
   sequence="100"
   script="map_shops"
  >
  
  </alias>  

 <alias
   match="mapper train"
   enabled="y"
   sequence="100"
   script="map_trainers"
  >
  
  </alias>  

 <alias
   match="mapper quest"
   enabled="y"
   sequence="100"
   script="map_quests"
  >
  
  </alias>  
        
<alias
   match="mapper heal"
   enabled="y"
   sequence="100"
   script="map_healers"
  >
  
  </alias>  
    
 <alias
   match="mapper goto *"
   enabled="y"
   sequence="100"
   script="map_goto"
  >
  
  </alias>  
    
 <alias
   match="mapper where *"
   enabled="y"
   sequence="100"
   script="map_where"
  >
  
  </alias>  
    
  <alias
   match="mapper bookmarks"
   enabled="y"
   sequence="100"
   script="map_bookmarks"
  >
  
  </alias>  

  <alias
   script="create_map_database"
   match="create gmcp database"
   enabled="y"
   sequence="100"
   ignore_case="y"
  >
  </alias>

  <alias
   match="mapper purgeall"
   enabled="y"
   sequence="100"
   script="map_purgeall"
  >
  
  </alias>  
  
   <alias
   match="mapper purgezone *"
   enabled="y"
   sequence="100"
   script="map_purgezone"
  >
  </alias>  


  <alias
   match="mapper savenew"
   enabled="y"
   sequence="100"
   script="map_savedirty"
  >
  
  </alias>  

  <alias
   match="mapper clearcache"
   enabled="y"
   sequence="100"
   script="map_clearcache"
  >
  
  </alias>  


  <alias
   match="mapper printrooms"
   enabled="y"
   sequence="100"
   script="map_printrooms"
  >
  
  </alias>  
        
 <alias
   match="mapper resume"
   enabled="y"
   sequence="100"
   script="map_resume"
  >
  
  </alias>  
    
  <!--  cancel speedwalking -->
  
 <alias
   match="mapper stop"
   enabled="y"
   sequence="100"
   script="mapper.cancel_speedwalk"
  >
  </alias>  

  <!--  show/hide mapper -->
      
  <alias
   match="mapper hide"
   enabled="y"
   sequence="100"
   script="mapper.hide"
  >
  </alias>  
  
   <alias
   match="mapper show"
   enabled="y"
   sequence="100"
   script="mapper.show"
  >
  </alias>  
  
</aliases>

<triggers>
 <trigger
 enabled="y"
 regexp="y"
 match="^\{rname\}((.*?)( \(G\))? (\(\d+\)))$"
 sequence="100"
 omit_from_output="y"
 script="running_room_name">
 </trigger>
 
 <trigger
 enabled="y"
 regexp="y"
 omit_from_output="y"
 match="^\{rname\}(.*)$"
 sequence="101"
 script="running_room_name">
 </trigger>
 
 <trigger
 enabled="y"
 match="Alas, you cannot go that way."
 sequence="100"
 script="running_room_error">
 </trigger>
 
 <trigger
 enabled="y"
 match="Too many run errors. Aborting speedwalk."
 sequence="100"
 script="running_room_error">
 </trigger>
 
  <!--  auto-swim -->
 
 <trigger
   enabled="y"
   match="There's water ahead of you. You'll have to * to make it through."
   sequence="100"
  >
  <send>%1</send>
  </trigger>
  
 <trigger
   enabled="y"
   match="You'll have to swim to make it through the water in that direction."
   send_to="12"
   sequence="100"
  >
  <send>
    if last_direction_moved then
      Send ("swim " .. last_direction_moved)
    end -- if
  </send>
  </trigger>
  
  <!-- auto-open -->
  
  <trigger
   enabled="y"
   regexp="y"
   match="^There is a door in the way"
   send_to="12"
   sequence="100"
  >
  <send>
    if last_direction_moved then
      Send ("open door " .. last_direction_moved)
    end -- if
  </send>
  </trigger>
  
  <!--  various messages that cancel speedwalks -->
  
  <trigger
   enabled="y"
   match="Now now\, don\'t be so hasty\!$"
   regexp="y"
   script="mapper.cancel_speedwalk"
   sequence="100"
  > 
  </trigger>
  
  <trigger
   enabled="y"
   match="^You cannot walk through"
   regexp="y"
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  
  <trigger
   enabled="y"
   match="As you stroll in, you feel your feet slipping on something slimy."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  <send>stand</send>
  </trigger>
  
  <trigger
   enabled="y"
   match="The door is locked."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  
  <trigger
   enabled="y"
   match="You are regaining balance and are unable to move."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You are surrounded by a pocket of air and so must move normally through water."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="You fumble about drunkenly."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  
  <trigger
   enabled="y"
   match="You are asleep and can do nothing. WAKE will attempt to wake you."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  
   <trigger
   enabled="y"
   match="You must be standing first."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
  
   <trigger
   enabled="y"
   match="You need to use a boat, fly, or swim underwater to go there."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger> 
  
  <trigger
   enabled="y"
   match="You can't * while sitting."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger> 
  
 <trigger
   enabled="y"
   regexp="y"
   match="^You dream about "
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>
   
 <trigger
   enabled="y"
   match="There is no exit in that direction."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger> 
  
 <trigger
   enabled="y"
   match="Alas, you cannot go that way."
   script="mapper.cancel_speedwalk"
   sequence="100"
  >
  </trigger>   
  
</triggers>



<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="mapper help"
   enabled="y"
  >
  </alias>
</aliases>

<!--  Script  -->


<script>

local show_vnums = &show_vnums;
local show_timing = &show_timing;
local show_completed = &show_completed;
local show_database_mods = &show_database_mods;
local show_other_areas = &show_other_areas;
local show_up_down = &show_up_down;
local show_area_exits = &show_area_exits;
local speedwalk_prefix = "&speedwalk_prefix;"

<![CDATA[

require "serialize"
require "checkplugin"
mapper = require "aardmapper"
require "gmcphelper"
require "tprint"

-- Mapper Variables --

default_config = {
  -- assorted colours
  BACKGROUND_COLOUR       = { name = "Background",        colour =  ColourNameToRGB "#222024", },
  ROOM_COLOUR             = { name = "Room",              colour =  ColourNameToRGB "#dcdcdc", },
  EXIT_COLOUR             = { name = "Exit",              colour =  ColourNameToRGB "#e0ffff", },
  EXIT_COLOUR_UP_DOWN     = { name = "Exit up/down",      colour =  ColourNameToRGB "#ffb6c1", },
  EXIT_COLOUR_IN_OUT      = { name = "Exit in/out",       colour =  ColourNameToRGB "#e87537", },
  OUR_ROOM_COLOUR         = { name = "Our room",          colour =  ColourNameToRGB "#ff1493", },
  UNKNOWN_ROOM_COLOUR     = { name = "Unknown room",      colour =  ColourNameToRGB "#8b0000", },
  DIFFERENT_AREA_COLOUR   = { name = "Another area",      colour =  ColourNameToRGB "#ff0000", },
  SHOP_FILL_COLOUR        = { name = "Shop",              colour =  ColourNameToRGB "#ffad2f", },
  POSTOFFICE_FILL_COLOUR  = { name = "Post Office",       colour =  ColourNameToRGB "#9acd32", },
  BANK_FILL_COLOUR        = { name = "Bank",              colour =  ColourNameToRGB "#ffD700", },
  NEWSROOM_FILL_COLOUR    = { name = "Newsroom",          colour =  ColourNameToRGB "lightblue", },
  MAPPER_NOTE_COLOUR      = { name = "Messages",          colour =  ColourNameToRGB "lightgreen" },
  
  ROOM_NAME_TEXT          = { name = "Room name text",    colour = ColourNameToRGB "#BEF3F1", },
  ROOM_NAME_FILL          = { name = "Room name fill",    colour = ColourNameToRGB "#105653", },
  ROOM_NAME_BORDER        = { name = "Room name box",     colour = ColourNameToRGB "black", },
  
  AREA_NAME_TEXT          = { name = "Area name text",    colour = ColourNameToRGB "#BEF3F1",},
  AREA_NAME_FILL          = { name = "Area name fill",    colour = ColourNameToRGB "#105653", },   
  AREA_NAME_BORDER        = { name = "Area name box",     colour = ColourNameToRGB "black", },
               
  FONT = { name =  get_preferred_font {"Dina",  "Lucida Console",  "Fixedsys", "Courier", "Sylfaen",} ,
           size = 8
         } ,
         
  -- size of map window
  WINDOW = { width = 250, height = 400 },
  
  -- how far from where we are standing to draw (rooms)
  SCAN = { depth = 15 },
  
  -- speedwalk delay
  DELAY = { time = 0.0 },
  
  -- how many seconds to show "recent visit" lines (default 3 minutes)
  LAST_VISIT_TIME = { time = 60 * 3 },  
  
  }

local rooms = {}
local areas = {}
local dirty_rooms = {}
local environments = {}
local user_terrain_colour = {}

room_not_in_database = {}
room_in_database = {}

-- Create Database Variables --

count = 0
roomcount = 0
endroomcount = 0
areacount = 0
coordcount = 0
directioncount = 0
environmentcount = 0

entities = { ['&amp;']  = '&';
             ['&quot;'] = '"';
             ['&lt;']   = '<';
             ['&gt;']   = '>';
           }
       
directions = {}
    
convert_direction = {
  north = "n",
  south = "s",
  east = "e",
  west = "w",
  up = "u",
  down = "d",
  northeast = "ne",
  northwest = "nw",
  southeast = "se",
  southwest = "sw",
  ['in'] = "in",
  out = "out",
  }

function dbcheck (code)

 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg ()  -- the rollback will change the error message
    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
    error (err, 2)            -- show error in caller's context
  end -- if

end -- dbcheck 

function fixsql (s)
  
  if s then
    return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end -- if
end -- fixsql

function fixbool (b)
  if b then
    return 1
  else
    return 0
  end -- if
end -- fixbool

function save_room_to_database (uid,room) 
  
  assert (uid, "No UID supplied to save_room_to_database")

  dbcheck (db:execute (string.format (
        "INSERT INTO rooms (uid, name, terrain, info, x, y, z, area, date_added) VALUES (%s, %s, %s, %s, %i, %i, %i, %s, DATETIME('NOW'));",
          fixsql (uid), 
          fixsql (room.name),
          fixsql (room.terrain), 
          fixsql (room.info),
          room.x, room.y, room.z, fixsql(room.area)
        )))
        
  dbcheck (db:execute (string.format ([[
        INSERT INTO rooms_lookup (uid, name) VALUES (%s, %s);
      ]], fixsql  (uid),       
          fixsql  (room.name) 
          )))

  room_not_in_database [uid] = false
  
  if show_database_mods then
    mapper.mapprint ("Added room", uid, "to database. Name:", room.name)
  end -- if
  
end -- function save_room_to_database

function map_savedirty()

  db:exec ("BEGIN TRANSACTION;") 
  ctr = 0

  for uid,room in pairs(dirty_rooms) do
     
     save_room_to_database(uid,room)
     save_room_exits(uid)     
     ctr = ctr + 1  
  end -- for each dirty room
  
  db:exec ("COMMIT;") 
   
  if show_database_mods then
    mapper.mapprint ("Saved ", ctr, " dirty rooms.")
  end -- if

  dirty_rooms = {}

end
      
function fix_up_exit ()

  local room = rooms [from_room]
  
  dbcheck (db:execute (string.format ([[
      UPDATE exits SET touid = %s WHERE fromuid = %s AND dir = %s;
    ]], 
        fixsql  (current_room),     -- destination room
        fixsql  (from_room),       -- from previous room
        fixsql  (last_direction_moved)  -- direction (eg. "n")
        )))
        
  if show_database_mods then
    mapper.mapprint ("Fixed exit", last_direction_moved, "from room", from_room, "to be to", current_room)
  end -- if
  
  room.exits [last_direction_moved] = current_room
    
  last_direction_moved = nil
  from_room = nil
  
end -- fix_up_exit

function map_purgezone (name, line, wildcards)
  local zonename = string.gsub(wildcards[1], "^%s*(.-)%s*$", "%1")
  if zonename == nil or zonename == "" then
     mapper.mapprint("Syntax: mapper purgezone [zone key]")
     return
  end

  -- Delete the exit links or we get foreign key constraint errors.
  dbcheck (db:execute (string.format ("delete from exits where touid in (select uid from rooms where area = %s);",fixsql(zonename))))
  dbcheck (db:execute (string.format ("delete from exits where fromuid in (select uid from rooms where area = %s);",fixsql(zonename))))        
  dbcheck (db:execute (string.format ("DELETE from rooms where area = %s;", fixsql(zonename))))

  rooms = {}
  mapper.mapprint ("Purged all rooms from " .. zonename .. " and local cache.")
   return
end 

function map_purgeall() 
   dbcheck (db:execute [[
       DELETE from rooms_lookup;
       DELETE from exits;
       DELETE from rooms;
       ]])
   rooms = {}

   if show_database_mods then
     mapper.mapprint ("Purged all rooms from database and local cache.")
   end -- if
   return
end 

function map_clearcache() 
   rooms = {}

   if show_database_mods then
     mapper.mapprint ("Cleared local room cache.")
   end -- if

   return
end 

function map_printrooms() 
   tprint(rooms)
   return
end 

function load_room_from_database (uid)

  local room
 
  assert (uid, "No UID supplied to load_room_from_database")
  
  -- if not in database, don't look again
  if room_not_in_database [uid] then
    return nil
  end -- no point looking
  
  for row in db:nrows(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (uid))) do
     room = {
       name = row.name,
       area = row.area,
       building = row.building,
       terrain = row.terrain,
       info = row.info,
       notes = row.notes,
       x = row.x,
       y = row.y,
       z = row.z,
  
       exits = {} }
      
    for exitrow in db:nrows(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (uid))) do
       room.exits [exitrow.dir] = tostring (exitrow.touid)
    end -- for each exit
    
  end   -- finding room

  if room then
    rooms [uid] = room
    for row in db_bm:nrows(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (uid))) do
      rooms [uid].notes = row.notes
    end   -- finding room
        
    return room
  end -- if found
  
  room_not_in_database [uid] = true
  return nil
    
end -- load_room_from_database

function create_tables ()
  -- create rooms table
  dbcheck (db:execute[[
  
  PRAGMA foreign_keys = ON;
  PRAGMA journal_mode=WAL;

  CREATE TABLE IF NOT EXISTS areas (
      areaid      INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum or how the MUD identifies the area
      name        TEXT,               -- name of area
      date_added  DATE,               -- date added to database
      texture     TEXT,               -- background area texture
      color       TEXT,               -- ANSI colour code.
      UNIQUE (uid)
    );

  CREATE TABLE IF NOT EXISTS environments (
      environmentid INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT    NOT NULL,   -- code for the environment
      name          TEXT,               -- name of environment
      color         INTEGER,            -- ANSI colour code
      date_added    DATE,               -- date added to database
      UNIQUE (uid)
    );
  CREATE INDEX IF NOT EXISTS name_index ON environments (name);
   
  CREATE TABLE IF NOT EXISTS rooms (
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,            -- name of room
      area          TEXT,            -- which area
      building      TEXT,            -- which building it is in
      terrain       TEXT,            -- eg. road OR water
      info          TEXT,            -- eg. shop,postoffice
      notes         TEXT,            -- player notes
      x             INTEGER,
      y             INTEGER,
      z             INTEGER,
      date_added    DATE,            -- date added to database
      UNIQUE (uid)
    );
  CREATE INDEX IF NOT EXISTS info_index ON rooms (info);
  CREATE INDEX IF NOT EXISTS terrain_index ON rooms (terrain);
  CREATE INDEX IF NOT EXISTS area_index ON rooms (area);

  CREATE TABLE IF NOT EXISTS exits (
      exitid      INTEGER PRIMARY KEY AUTOINCREMENT,
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     STRING  NOT NULL, -- exit from which room (in rooms table)
      touid       STRING  NOT NULL, -- exit to which room (in rooms table)
      date_added  DATE,             -- date added to database
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
    );
  CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
  CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
  
  ]])
  
  -- check if rooms_lookup table exists
  local table_exists
  for a in db:nrows "SELECT * FROM sqlite_master WHERE name = 'rooms_lookup' AND type = 'table'" do
    table_exists = true
  end  -- for
  
  if not table_exists then
    dbcheck (db:execute "CREATE VIRTUAL TABLE rooms_lookup USING FTS3(uid, name);")
    -- in case we only deleted the rooms_lookup table to save space in the download
    dbcheck (db:execute "INSERT INTO rooms_lookup (uid, name) SELECT uid, name FROM rooms;")
  end -- if
  
  -- create bookmarks and terrain colours table in separate database
  dbcheck (db_bm:execute[[
  
  PRAGMA foreign_keys = ON;
  
  CREATE TABLE IF NOT EXISTS bookmarks (
      id          INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum of room
      notes       TEXT,               -- user notes
      date_added  DATE,               -- date added to database
      UNIQUE (uid)
    );
    
  CREATE TABLE IF NOT EXISTS terrain (
      id          INTEGER PRIMARY KEY AUTOINCREMENT,
      name        TEXT    NOT NULL,   -- terrain name
      color       INTEGER,            -- RGB code
      date_added  DATE,               -- date added to database
      UNIQUE (name)
    );
        
    
  ]])
      
end -- function create_tables

function get_room (uid)

  -- check we got room at all
  if not uid then
   -- return nil
  end -- if
  
  -- look it up
  local ourroom = rooms [uid]
  
  -- not cached - see if in database
  if not ourroom then
    ourroom = load_room_from_database (uid)
    rooms [uid] = ourroom -- cache for later
  end -- not in cache
  
  if not ourroom then
     return nil
  end -- if

  local room = copytable.deep (ourroom)
  room.bordercolour = config.ROOM_COLOUR.colour
  if areas[room.area] then
     room.texture = areas[room.area].texture
     if areas[room.area].color ~= "" then
        room.bordercolour = areas[room.area].color or config.ROOM_COLOUR.colour
     end
     room.area = areas[room.area].name or string.format ("%s", room.area or "<unknown>")
  end
   
  if uid == current_room then
    current_area = room.area
  end -- if
  
  -- build hover message  
  local environmentname = room.terrain
  if tonumber (environmentname) then
    environmentname = environments [tonumber (environmentname)]
  end -- convert to name
  
  local terrain = ""
  if environmentname then
    terrain = "\nTerrain: " .. capitalize (environmentname)
  end -- if terrain known
  
  local info = ""
  if room.info then
    info = "\nInfo: " .. capitalize (room.info)
  end -- if info known
  
  local notes = ""
  if room.notes then
    notes = "\nBookmark: " .. room.notes
  end -- if notes
  
  local texits = {}
  for dir in pairs (room.exits) do
    table.insert (texits, dir)
  end -- for
  table.sort (texits)
   
  local areaname = room.area
  if tonumber (areaname) then
    areaname = areas [tonumber (areaname)].name
  end -- convert to name
    
  room.hovermessage = string.format (
      "%s\tExits: %s\nRoom: %s\nArea: %s%s%s%s",
      room.name, 
      table.concat (texits, ", "),
      uid,
      areaname,
      terrain,
      info,
      notes
      -- depth,
      -- table.concat (path, ",")
      )
      

  --room.bordercolour = config.ROOM_COLOUR.colour
  room.borderpen = 0 -- solid
  room.borderpenwidth = 1
  room.fillcolour = 0xff0000
  room.fillbrush = 1 -- no fill
              
  -- special room fill colours
  
  if room.info then
    if string.match (room.info, "shop") then
      room.fillcolour = config.SHOP_FILL_COLOUR.colour
      room.fillbrush = 8
    elseif string.match (room.info, "postoffice") then
      room.fillcolour = config.POSTOFFICE_FILL_COLOUR.colour
      room.fillbrush = 8
    elseif string.match (room.info, "bank") then
      room.fillcolour = config.BANK_FILL_COLOUR.colour
      room.fillbrush = 8
    elseif string.match (room.info, "newsroom") then
      room.fillcolour = config.NEWSROOM_FILL_COLOUR.colour
      room.fillbrush = 8
    end -- if
  else  
    -- use terrain colour
    if environmentname then
      if user_terrain_colour [environmentname] then
        room.fillcolour = user_terrain_colour [environmentname]
        room.fillbrush = 0  -- solid
      elseif terrain_colours [environmentname] then
        room.fillcolour = colour_lookup [terrain_colours [environmentname]]
        room.fillbrush = 8  -- solid
      end
    end -- if environmentname
  end -- if 

  if uid == current_room then
    room.bordercolour = config.OUR_ROOM_COLOUR.colour
    room.borderpenwidth = 2
  elseif room.area ~= current_area then
    room.bordercolour = config.DIFFERENT_AREA_COLOUR.colour
  end -- not in this area
  
  return room      
      
end -- get_room

function room_edit_bookmark (room, uid)

  local notes, found
  
  for row in db_bm:nrows(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (uid))) do
    notes = row.notes
    found = true
  end   -- finding room
  
  if found then  
    newnotes = utils.inputbox ("Modify room comment (clear it to delete from database)", room.name, notes)
  else
    newnotes = utils.inputbox ("Enter room comment (creates a bookmark for this room)", room.name, notes)
  end -- if
  
  if not newnotes then
    return
  end -- if cancelled 
  
  if newnotes == "" then
    if not found then
      mapper.mapprint ("No comment entered, bookmark not saved.")
      return
    else
      dbcheck (db_bm:execute (string.format (
        "DELETE FROM bookmarks WHERE uid = %s;",
          fixsql (uid)
        )))
      mapper.mapprint ("Bookmark for room", uid, "deleted. Was previously:", notes)
      rooms [uid].notes = nil
      return
    end -- if
  end -- if
  
  if notes == newnotes then
    return -- no change made
  end -- if
  
  if found then
    dbcheck (db_bm:execute (string.format (
        "UPDATE bookmarks SET notes = %s, date_added = DATETIME('NOW') WHERE uid = %s;",
          fixsql (newnotes),
          fixsql (uid)
        )))
     mapper.mapprint ("Bookmark for room", uid, "changed to:", newnotes)
   else
    dbcheck (db_bm:execute (string.format (
        "INSERT INTO bookmarks (uid, notes, date_added) VALUES (%s, %s, DATETIME('NOW'));",
          fixsql (uid), 
          fixsql (newnotes)
        )))
     mapper.mapprint ("Bookmark added to room", uid, ":", newnotes)
   end -- if    
   
   rooms [uid].notes = newnotes
   
end -- room_edit_bookmark

function room_edit_terrain_colour (room, uid)

  if not room.terrain then
    utils.msgbox ("This room does not have a terrain type", "Unknown terrain!", "ok", "!", 1)
    return
  end -- not known
   
  local environmentname = room.terrain
  if tonumber (environmentname) then
    environmentname = environments [tonumber (environmentname)]
  end -- convert to name
  
  local colour
  local colourtype = terrain_colours [environmentname]
    
  if colourtype then 
    colour = colour_lookup [colourtype]
  end -- if type known

  if user_terrain_colour [environmentname] then
    colour = user_terrain_colour [environmentname]
  end -- if already have user colour
  
  local newcolour = PickColour (colour or 0x000000)
  if newcolour == -1 or newcolour == colour then
    return
  end -- cancelled
  
  if user_terrain_colour [environmentname] then
    dbcheck (db_bm:execute (string.format (
        "UPDATE terrain SET color = %s, date_added = DATETIME('NOW') WHERE name = %s;",
          fixsql (newcolour),
          fixsql (environmentname)
        )))
     mapper.mapprint ("Colour for terrain '" .. environmentname .. "' changed to:", RGBColourToName (newcolour))
   else
    dbcheck (db_bm:execute (string.format (
        "INSERT INTO terrain (name, color, date_added) VALUES (%s, %s, DATETIME('NOW'));",
          fixsql (environmentname), 
          fixsql (newcolour)
        )))
     mapper.mapprint ("Colour for terrain '" .. environmentname .. "' is now", RGBColourToName (newcolour))
   end -- if    
   
   user_terrain_colour [environmentname] = newcolour

   mapper.draw (current_room)

end -- room_edit_terrain_colour

function room_add_exit (room, uid)

local available =  {
  n = "North",
  s = "South",
  e = "East",
  w = "West",
  u = "Up",
  d = "Down",
  ne = "Northeast",
  sw = "Southwest",
  nw = "Northwest",
  se = "Southeast",
  ['in'] = "In",
  out = "Out",
  }  -- end of available

  -- remove existing exits
  for k in pairs (room.exits) do
    available [k] = nil
  end -- for
  
  if next (available) == nil then
    utils.msgbox ("All exits already used.", "No free exits!", "ok", "!", 1)
    return
  end -- not known
  
  local chosen_exit = utils.listbox ("Choose exit to add", "Exits ...", available )
  if not chosen_exit then
    return
  end
  
  exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. available [chosen_exit], room.name, "")

  if not exit_destination then
    return
  end -- cancelled
  
    -- look it up
  local dest_room = rooms [exit_destination]
  
  -- not cached - see if in database
  if not dest_room then
    dest_room = load_room_from_database (exit_destination)
    rooms [exit_destination] = dest_room -- cache for later
  end -- not in cache
  
  if not dest_room then
    utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
    return
  end -- if still not there

  dbcheck (db:execute (string.format ([[
    INSERT INTO exits (dir, fromuid, touid, date_added) 
        VALUES (%s, %s, %s, DATETIME('NOW'));
  ]], fixsql  (chosen_exit),  -- direction (eg. "n")
      fixsql  (uid),  -- from current room
      fixsql  (exit_destination) -- destination room 
      )))
  if show_database_mods then
    mapper.mapprint ("Added exit", available [chosen_exit], "from room", uid, "to room", exit_destination, "to database.")
  end -- if
  
  -- update in-memory table
  rooms [uid].exits [chosen_exit] = exit_destination
  
  mapper.draw (current_room)
   
end -- room_add_exit


function room_delete_exit (room, uid)

local available =  {
  n = "North",
  s = "South",
  e = "East",
  w = "West",
  u = "Up",
  d = "Down",
  ne = "Northeast",
  sw = "Southwest",
  nw = "Northwest",
  se = "Southeast",
  ['in'] = "In",
  out = "Out",
  }  -- end of available

  -- remove non-existent exits
  for k in pairs (available) do
    if room.exits [k] then
      available [k] = available [k] .. " --> " .. room.exits [k] 
    else
      available [k] = nil
    end -- if not a room exit
  end -- for
  
  if next (available) == nil then
    utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
    return
  end -- not known
  
  local chosen_exit = utils.listbox ("Choose exit to delete", "Exits ...", available )
  if not chosen_exit then
    return
  end

  dbcheck (db:execute (string.format ([[
    DELETE FROM exits WHERE dir = %s AND fromuid = %s;
  ]], fixsql  (chosen_exit),  -- direction (eg. "n")
      fixsql  (uid)  -- from current room
      )))
  if show_database_mods then
    mapper.mapprint ("Deleted exit", available [chosen_exit], "from room", uid, "from database.")
  end -- if
  
  -- update in-memory table
  rooms [uid].exits [chosen_exit] = nil
  
  mapper.draw (current_room)
   
end -- room_delete_exit


function room_change_exit (room, uid)

local available =  {
  n = "North",
  s = "South",
  e = "East",
  w = "West",
  u = "Up",
  d = "Down",
  ne = "Northeast",
  sw = "Southwest",
  nw = "Northwest",
  se = "Southeast",
  ['in'] = "In",
  out = "Out",
  }  -- end of available

  -- remove non-existent exits
  for k in pairs (available) do
    if room.exits [k] then
      available [k] = available [k] .. " --> " .. room.exits [k] 
    else
      available [k] = nil
    end -- if not a room exit
  end -- for
  
  if next (available) == nil then
    utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
    return
  end -- not known
  
  local chosen_exit = utils.listbox ("Choose exit to change destination of:", "Exits ...", available )
  if not chosen_exit then
    return
  end

  exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. available [chosen_exit], room.name, "")

  if not exit_destination then
    return
  end -- cancelled
  
    -- look it up
  local dest_room = rooms [exit_destination]
  
  -- not cached - see if in database
  if not dest_room then
    dest_room = load_room_from_database (exit_destination)
    rooms [exit_destination] = dest_room -- cache for later
  end -- not in cache
  
  if not dest_room then
    utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
    return
  end -- if still not there
    
  dbcheck (db:execute (string.format ([[
    UPDATE exits SET touid = %s WHERE dir = %s AND fromuid = %s;
  ]], fixsql  (exit_destination),
      fixsql  (chosen_exit),  -- direction (eg. "n")
      fixsql  (uid)  -- from current room
      )))
      
  if show_database_mods then
    mapper.mapprint ("Modified exit", available [chosen_exit], "from room", uid, "to be to room", exit_destination, "in database.")
  end -- if
  
  -- update in-memory table
  rooms [uid].exits [chosen_exit] = exit_destination
  mapper.draw (current_room)
   
end -- room_change_exit

function change_room_area (room, uid)
   
  if next (areas) == nil then
    mapper.maperror("There are no available areas to choose from.")
    return
  end -- if
  
  local chosen_area = utils.listbox ("Choose the area this room belongs to:", "Areas ...", areas)
   
  if not chosen_area then
    return
  end -- if
  
  rooms[uid].area = chosen_area
  mapper.draw (current_room)
  
  dbcheck (db:execute (string.format ([[
    UPDATE rooms SET area = %s WHERE uid = %s;
  ]], fixsql  (chosen_area),  -- area (e.g. "1" for "western ithmia")
      fixsql  (uid)  -- from current room
      )))
end -- change_room_area

function room_click (uid, flags)

  -- check we got room at all
  if not uid then
    return nil
  end -- if
  
  -- look it up
  local room = rooms [uid]
  
  -- not cached - see if in database
  if not room then
    room = load_room_from_database (uid)
    rooms [uid] = room -- cache for later
  end -- not in cache
  
  if not room then
    return
  end -- if still not there
  
  local handlers = {
      { name = "Edit bookmark", func = room_edit_bookmark} ,
      { name = "Edit terrain colour", func = room_edit_terrain_colour} ,
      { name = "-", } ,
--      { name = "^Exits", } ,
      { name = "Add Exit", func = room_add_exit} ,
      { name = "Change Exit", func = room_change_exit} ,
      { name = "Delete Exit", func = room_delete_exit} ,
      { name = "Set area", func = change_room_area} ,
      } -- handlers
      
  local t, tf = {}, {}
  for _, v in pairs (handlers) do
    table.insert (t, v.name)
    tf [v.name] = v.func
  end -- for
      
  local choice = WindowMenu (mapper.win, 
                            WindowInfo (mapper.win, 14), 
                            WindowInfo (mapper.win, 15), 
                            table.concat (t, "|"))
   
  local f = tf [choice]
  
  if f then
    f (room, uid)
  end -- if handler found
                           
end -- room_click

function OnPluginInstall ()
  
  config = {}  -- in case not found

  fonts = utils.getfontfamilies ()

  -- if not there already, add it
  if not fonts.Dina then
    AddFont (GetInfo (66) .. "\\Dina.fon")
  end -- if Dina not installed

  -- get saved configuration
  assert (loadstring (GetVariable ("config") or "")) ()

  -- allow for additions to config
  for k, v in pairs (default_config) do
    config [k] = config [k] or v
  end -- for
  
  -- initialize mapper engine
  mapper.init { config = config,            -- colours, timing etc.
                get_room = get_room,        -- get_room (uid) called to get room info
                show_help = OnHelp,         -- to show help
                room_click = room_click,    -- called on RH click on room square
                timing = show_timing,       -- want to see timing
                show_completed = show_completed,  -- want to see "Speedwalk completed." message
                show_other_areas = show_other_areas,  -- want to see areas other than the current one?
                show_up_down = show_up_down,          -- want to follow up/down exits?
                show_area_exits = show_area_exits,    -- want to see area exits?
                speedwalk_prefix = speedwalk_prefix,  -- how to speedwalk
                } 
  
  mapper.mapprint (string.format ("MUSHclient mapper installed, version %0.1f", mapper.VERSION))
  
  -- open databases on disk 
  db    = assert (sqlite3.open(GetInfo (66) .. Trim (WorldName ()) .. ".db"))
  db_bm = assert (sqlite3.open(GetInfo (66) .. Trim (WorldName ()) .. "_bookmarks.db"))
  
  create_tables ()    -- create database structure if necessary
  
  -- grab all area names
  for row in db:nrows("SELECT * FROM areas") do
     area = {
       name = row.name,
       texture = row.texture,
       color = row.color
    }
    areas [row.uid] = area

  end   -- finding areas
  
  -- grab all user terrain info
  for row in db_bm:nrows("SELECT * FROM terrain") do
    user_terrain_colour [row.name] = row.color
  end   -- finding terrains
 
  -- grab all environment names
  for row in db:nrows("SELECT * FROM environments") do
    environments [tonumber (row.uid)] = row.name
    terrain_colours [row.name] = tonumber (row.color)
  end   -- finding environments
  
end -- OnPluginInstall

function OnPluginEnable ()
  mapper.show ()
end -- OnPluginDisable

function OnPluginDisable ()
  mapper.hide ()
end -- OnPluginDisable

-- hide window on removal
function OnPluginClose ()
  mapper.hide ()
  -- close databases
  db:close()
  db_bm:close()
end -- OnPluginClose

function OnPluginSaveState ()
  mapper.save_state ()
  if config.SCAN.depth < mapper.temp_scan_depth then
    config.SCAN.depth = mapper.temp_scan_depth
  end
  SetVariable ("config", "config = " .. serialize.save_simple (config))
end -- OnPluginSaveState
 
terrain_colours = {}


-- ANSI colours lookup (for terrain_colours)

colour_lookup = {
    [0] =   ColourNameToRGB  "black",  
    [1] =   ColourNameToRGB  "maroon", 
    [2] =   ColourNameToRGB  "green",  
    [3] =   ColourNameToRGB  "olive",  
    [4] =   ColourNameToRGB  "navy",   
    [5] =   ColourNameToRGB  "purple", 
    [6] =   ColourNameToRGB  "teal",   
    [7] =   ColourNameToRGB  "silver", 
    [8] =   ColourNameToRGB  "gray",   
    [9] =   ColourNameToRGB  "red",    
    [10] =  ColourNameToRGB  "lime",   
    [11] =  ColourNameToRGB  "yellow", 
    [12] =  ColourNameToRGB  "blue",   
    [13] =  ColourNameToRGB  "magenta",
    [14] =  ColourNameToRGB  "cyan",   
    [15] =  ColourNameToRGB  "white",  
  } -- end of colour_lookup

local running_room = ""

function running_room_error()
    running_room = ""
    Send_GMCP_Packet("request room")
end

function running_room_name (name, line, wildcards, styles)
    -- strip out tag
    tag_length = string.find(styles[1].text,"}")
    styles[1].text = string.sub(styles[1].text, tag_length+1)
    styles[1].length = styles[1].length-tag_length
    for _, v in ipairs (styles) do
        ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),v.text)
    end -- for each style run
    Note ("")  -- wrap up line
    
    if #wildcards == 4 then
       running_room = wildcards[2]
    else
       running_room = ""
    end
end

function got_gmcp_room()

  local room_number = gmcpval("num")
  if not(room_number) then return end -- no room number.got_gmcp_room
  current_room = room_number

  gmcproom = {
       name = gmcpval("name"),
       area = gmcpval("zone"),
       building = 0,
       terrain = gmcpval("terrain"),
       info = gmcpval("flags"),
       notes = "",
       x = gmcpval("coord.x"),
       y = gmcpval("coord.y"),
       z = 0,
       exits = {} }

  if mapper.running == false and gmcproom.name == running_room then
     mapper.activate_running(true)
  elseif mapper.running == true and gmcproom.name ~= running_room then
     mapper.activate_running(false)
  end
  
  local  exits      = gmcpval("exits")
  local room = rooms [room_number]
 
  -- not cached - see if in database
  if not room then
    room = load_room_from_database (room_number)
  end -- not in cache
  
  if not room then

     db:exec ("BEGIN TRANSACTION;") 
   
     room = gmcproom
     dirty_rooms[room_number] = room

     save_room_to_database (room_number,room)
     rooms[room_number] = room

     --if gmcpdata.exits ~= nil then
     --   for dir,touid in pairs(gmcpdata.exits) do
     --     room.exits [dir] = touid
     --   end -- if can decode    
     --aend

     save_room_exits(room_number)

     db:exec ("COMMIT;") 

  end -- if room not there
  
  mapper.draw(room_number)

  if expected_exit == "0" and from_room then
    fix_up_exit ()
  end -- exit was wrong
   
  return
end

function update_gmcp_area()

   local areaid = gmcpval("id")
   local areaname = gmcpval("name")
   local texture = gmcpval("texture")
   local color = gmcpval("col")
   local x,y,z = gmcpval("x"),gmcpval("y"),gmcpval("z")

  dbcheck (db:execute (string.format (
    "REPLACE INTO areas (uid, name, date_added, texture, color) VALUES (%s, %s, DATETIME('NOW'), %s, %s);",
      fixsql (areaid), 
      fixsql (areaname),
      fixsql (texture),
      fixsql (color)
    )))

    area = {
       name = areaname,
       texture = texture,
       color = color
    }
    areas [areaid] = area

return
end


function save_room_exits(uid) 

   local room = rooms[uid]

   if room == nil then
      return
   end

   if gmcpdata.exits ~= nil then

     for dir,touid in pairs(gmcpdata.exits) do

       if dir then

         -- fix up in and out
         dir = ({ ['i'] = "in", o = "out", }) [dir] or dir
      
         dbcheck (db:execute (string.format ([[
           INSERT INTO exits (dir, fromuid, touid, date_added) 
               VALUES (%s, %s, %s, DATETIME('NOW'));
         ]], fixsql  (dir),  -- direction (eg. "n")
             fixsql  (uid),  -- from current room
             fixsql  (touid) -- destination room 
             )))

         if show_database_mods then
           mapper.mapprint ("Added exit: ", dir, "from room: ",uid, "to room: ", touid, " to database.")
         end -- if

         room.exits [dir] = touid
       else
         mapper.maperror ("Cannot make sense of:", exit)
       end -- if can decode    
     end -- for each exit

  end -- have exits.
end -- save_room_exits

  
function OnPluginBroadcast (msg, id, name, text)

  if id == "3e7dedbe37e44942dd46d264" then 
    -- gmcphandler.
    if (text == "room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")

      luastmt = "gmcpdata = " .. gmcparg
      assert (loadstring (luastmt or "")) ()

      got_gmcp_room()

    end -- if room.info

    if (text == "room.wrongdir") then
       mapper.cancel_speedwalk()
    end -- wrongdir

    if (text == "room.area") then
       res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
       luastmt = "gmcpdata = " .. gmcparg
       assert (loadstring (luastmt or "")) ()
       update_gmcp_area()
    end -- room.zone

  end -- if gmcp msg.

end


function map_find (name, line, wildcards)
 
  local rooms = {}
  local count = 0
  
  -- find matching rooms using FTS3
  for row in db:nrows(string.format ("SELECT uid, name FROM rooms_lookup WHERE rooms_lookup MATCH %s", fixsql (wildcards [1]))) do
     rooms [row.uid] = true
     count = count + 1
  end   -- finding room
  
  -- see if nearby
  mapper.find (
    function (uid) 
      local room = rooms [uid] 
      if room then
        rooms [uid] = nil
      end -- if
      return room, next (rooms) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false       -- don't auto-walk
    )
  
end -- map_find


function map_find_special (which_ones)

local wanted_items = {}

  for _, v in ipairs (which_ones) do 
    wanted_items [v:lower ()] = true 
  end
            
  local rooms = {}
  local count = 0
  
  -- build table of special places (with info in them)
  for row in db:nrows(string.format ("SELECT uid, name, info FROM rooms WHERE info IS NOT NULL")) do
     if row.info ~= "" then
       local wanted = false
       local t = {}
       for item in string.gmatch (row.info, "[^,]+") do
          if wanted_items [item:lower ()] then 
            wanted = true
            table.insert (t, capitalize (item))
          end -- if
       end -- for
       if wanted then
         rooms [row.uid] = table.concat(t, ", ")
         count = count + 1
       end -- if
     end -- if
  end   -- finding room
  
  -- find such places
  mapper.find (
    function (uid) 
      local room = rooms [uid] 
      if room then
        rooms [uid] = nil
      end -- if
      return room, next (rooms) == nil  -- room will be type of info (eg. shop)
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false       -- don't auto-walk
    )
        
end -- map_find_special

  --[[
for _, v in ipairs ({
     
    -- "guild", "healer", "trainer", "questor",
            }) do wanted_items [v] = true end
      --]]
            
function map_shops (name, line, wildcards)
  map_find_special { "shop", "postoffice", "bank", "newsroom", }
end -- map_shops

function map_trainers (name, line, wildcards)
  map_find_special { "trainer", }
end -- map_trainers

function map_quests (name, line, wildcards)
  map_find_special { "questor", }
end -- map_quests

function map_healers (name, line, wildcards)
  map_find_special { "healers", }
end -- map_healers

function map_goto (name, line, wildcards)

  local wanted = wildcards [1]
  
  if current_room and wanted == current_room then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  
  -- find desired room
  mapper.find (
    function (uid) 
      return uid == wanted, uid == wanted  
    end,  -- function
    show_vnums,  -- show vnum?
    1,          -- how many to expect
    true        -- just walk there
    )
        
end -- map_goto

function map_where (name, line, wildcards)

  if not mapper.check_we_can_find () then
    return
  end -- if

  local wanted = wildcards [1]
  
  if current_room and wanted == current_room then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  
  local paths = mapper.find_paths (current_room, 
           function (uid) 
             return uid == wanted,  -- wanted room?
                    uid == wanted   -- stop searching?
            end)

  local uid, item = next (paths, nil) -- extract first (only) path
  
  -- nothing? room not found
  if not item then
    mapper.mapprint (string.format ("Room %s not found", wanted))
    return
  end -- if
  
  -- turn into speedwalk
  local path = mapper.build_speedwalk (item.path)
  
  -- display it
  mapper.mapprint (string.format ("Path to %s is: %s", wanted, path))
  
end -- map_where

function map_resume (name, line, wildcards)

  local wanted = mapper.last_hyperlink_uid or mapper.last_speedwalk_uid
  
  if not wanted then
    mapper.print "No outstanding speedwalks or hyperlinks."
    return
  end -- if nothing to do
  
  -- find desired room
  mapper.find (
    function (uid) 
      return uid == wanted, uid == wanted  

    end,  -- function
    show_vnums,  -- show vnum?
    1,      -- how many to expect
    true    -- just walk there
    )
        
end -- map_resume

function map_bookmarks (name, line, wildcards)

  local rooms = {}
  local count = 0
  
  -- build table of special places (with info in them)
  for row in db_bm:nrows(string.format ("SELECT uid, notes FROM bookmarks")) do
     rooms [row.uid] = capitalize (row.notes)
     count = count + 1
  end   -- finding room
  
  -- find such places
  mapper.find (
    function (uid) 
      local room = rooms [uid] 
      if room then
        rooms [uid] = nil
      end -- if
      return room, next (rooms) == nil  -- room will be type of info (eg. shop)
    end,  -- function
    show_vnums,  -- show vnum?
    count,       -- how many to expect
    false        -- don't auto-walk
    )
        
end -- map_bookmarks

function map_areas (name, line, wildcards)

  local wanted_areas = {}
  local count = 0
  
  if next (areas) == nil then
    mapper.maperror "No areas known."
    return
  end -- if
 
  -- build table of all areas, keyed by area code
  for k, v in pairs (areas) do
    wanted_areas [k] = v
    count = count + 1
  end -- for
    
  -- find all areas
  mapper.find (
    function (uid) 
      local room = rooms [uid]
      local reason
      -- if this room is in the list of wanted areas then save its path
      if wanted_areas[room.area] then
        reason = wanted_areas [room.area]
        wanted_areas [room.area] = nil
      end -- found one!
      return reason, next (wanted_areas) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,       -- how many to expect
    false        -- don't auto-walk
    )
    
end -- map_areas


valid_direction = {
  n = "n",
  s = "s",
  e = "e",
  w = "w",
  u = "u",
  d = "d",
  ne = "ne",
  sw = "sw",
  nw = "nw",
  se = "se",
  north = "n",
  south = "s",
  east = "e",
  west = "w",
  up = "u",
  down = "d",
  northeast = "ne",
  northwest = "nw",
  southeast = "se",
  southwest = "sw",
  ['in'] = "in",
  out = "out",
  }  -- end of valid_direction
  
-- try to detect when we send a movement command
function OnPluginSent (sText)
  if valid_direction [sText] then
    last_direction_moved = valid_direction [sText]
--    print ("Just moved", last_direction_moved)
    if current_room and rooms [current_room] then
      expected_exit = rooms [current_room].exits [last_direction_moved]
      if expected_exit then
        from_room = current_room
      end -- if
--     print ("expected exit for this direction is to room", expected_exit)
    end -- if
  end -- if 
end -- function

function OnPluginConnect ()
  Send_GMCP_Packet("rawcolor on")
  mapper.cancel_speedwalk ()
  -- DoAfter (3, "look")  -- force mapper update
end -- OnPluginConnect

function OnPluginDisconnect ()
  mapper.cancel_speedwalk ()
end -- OnPluginConnect

function OnHelp ()
  mapper.mapprint (string.format ("[MUSHclient mapper, version %0.1f]", mapper.VERSION))
  mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
end

function OnPluginListChanged ()
  do_plugin_check_now ("3e7dedbe37e44942dd46d264", "GMCP_handler")    -- check we have ATCP plugin
end -- OnPluginListChanged


--
-- Functions used by create GMCP database - initial load of XML files.
--
  
function process_area (args)
 
  if not args.id and args.name then
    return "Need id and name"
  end -- if
  
  areacount = areacount + 1
 
  dbcheck (db:execute (string.format (
    "INSERT INTO areas (uid, name, date_added, texture, color) VALUES (%s, %s, DATETIME('NOW'), %s, %s);",
      fixsql (args.id), 
      fixsql (args.name),
      fixsql (args.texture),
      fixsql (args.col)
    )))
          
end --  process_area 

function  process_environment (args)
 
  if not args.id and args.name and args.color then
    return "Need id, name, color"
  end -- if
  
  environmentcount = environmentcount + 1
  
  dbcheck (db:execute (string.format (
    "INSERT INTO environments (uid, name, color, date_added) VALUES (%s, %s, %i, DATETIME('NOW'));",
      fixsql (args.id), 
      fixsql (args.name),
      args.color
    )))
               
end --  process_environment 

function  process_info (args)
 
  if not args.flags then
    return "Need flags"
  end -- if
  
  info = args.flags
               
end --  process_environment 
          
function process_start_room (args)
  if not args.id and args.area and args.title and args.environment then
    return "Need id, area, title, environment"
  end -- if

  roomcount = roomcount + 1
  
  SetStatus ("Processing room " .. args.id ..  " (" .. roomcount .. ") - " .. args.title )

  room = { id = args.id, area = args.area, title = args.title, terrain = args.environment }
  exits = {}
  coords = {}
  info = nil
end -- process_start_room

function process_end_room ()
  endroomcount = endroomcount + 1
  local building = coords.building
  local x, y, z = coords.x or 0, coords.y or 0, coords.z or 0
  dbcheck (db:execute (string.format (
    "INSERT INTO rooms (uid, name, area, terrain, building, info, x, y, z, date_added) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, DATETIME('NOW'));",
      fixsql (room.id), 
      fixsql (room.title),
      fixsql (room.area),
      fixsql (room.terrain),
      fixsql (building),
      fixsql (info),
      fixsql (coords.x),
      fixsql (coords.y),
      fixsql (coords.z)
    )))
  
  for dir, exit in pairs (exits) do
     dbcheck (db:execute (string.format ([[
        INSERT INTO exits (dir, fromuid, touid, date_added) 
            VALUES (%s, %s, %s, DATETIME('NOW'));
      ]], fixsql  (dir),  -- direction (eg. "n")
          fixsql  (room.id),         -- from current room
          fixsql  (exit)    -- destination room
          )))
  end -- for each exit

  dbcheck (db:execute (string.format ([[
    INSERT INTO rooms_lookup (uid, name) VALUES (%s, %s);
  ]], fixsql  (room.id),       
      fixsql  (room.title) 
      )))
            
end -- process_end_room

function process_coord (args)
  coordcount = coordcount + 1
  coords = { x = args.x, y = args.y, z = args.z, building = args.building, area = args.area }
end -- process_coord

function process_exit (args)

  if not args.direction and args.target then
    return "Need direction and target"
  end -- if

  directioncount = directioncount + 1
  
  if  not convert_direction [args.direction] then
    print ("Don't know of direction", args.direction)
  end -- if
  
  directions [args.direction] = (directions [args.direction] or 0) + 1
  exits [(convert_direction [args.direction]) or args.direction] = args.target
end -- process_exit

function dbcheck (code)

 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg ()  -- the rollback will change the error message
    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
    error (err, 2)            -- show error in caller's context
  end -- if

end -- dbcheck 

function fixsql (s)
  if s then
    return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end -- if
end -- fixsql

function fixbool (b)
  if b then
    return 1
  else
    return 0
  end -- if
end -- fixbool

function ignore (args)
  -- ignore this tag
end -- ignore

handlers = {
  areas = ignore,
  map = ignore,
  rooms = ignore,
  environments = ignore,
  ["/areas"] = ignore,
  ["/rooms"] = ignore,
  ["/map"] = ignore,
  ["/environments"] = ignore,
  
  area = process_area,
  room = process_start_room,
  coord = process_coord,
  environment = process_environment,
  exit = process_exit,
  info = process_info,
  ["/room"] = process_end_room,
  }
  
function get_params (s)
  local t = {}
  
  for name, contents in string.gmatch (s, '(%a+)="([^"]*)"') do
    t [name] = string.gsub (contents, '&%a-;', entities)
  end -- for
  
  return t

end -- get_params

function create_map_database (name, line, wildcards)

  local filename = utils.filepicker ("Mapper database", "", "xml", { xml = "XML files", ["*"] = "All files" }, false)
  
  if not filename then
    return -- they cancelled
  end

  -- open database on disk 
  db = assert (sqlite3.open(GetInfo (66) .. Trim (WorldName ()) .. ".db") )
  
  -- create rooms table
  dbcheck (db:execute[[
  
  PRAGMA foreign_keys = ON;
  PRAGMA journal_mode=WAL;
  
  DROP TABLE IF EXISTS exits;
  DROP TABLE IF EXISTS rooms;
  DROP TABLE IF EXISTS areas;
  DROP TABLE IF EXISTS environments;
  
  CREATE TABLE areas (
      areaid      INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum or how the MUD identifies the area
      name        TEXT,               -- name of area
      date_added  DATE,               -- date added to database
      texture     TEXT,               -- background area texture
      color       TEXT,               -- RGB room colour code so we don't conflict with texture
      UNIQUE (uid)
    );

  
  CREATE TABLE environments (
      environmentid INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT    NOT NULL,   -- code for the environment

      name          TEXT,               -- name of environment
      color         INTEGER,            -- ANSI colour code
      date_added    DATE,               -- date added to database
      UNIQUE (uid)
    );
    
  CREATE INDEX IF NOT EXISTS name_index ON environments (name);

  CREATE TABLE rooms (
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,            -- name of room
      area          TEXT,            -- which area
      building      TEXT,            -- which building it is in
      terrain       TEXT,            -- eg. road OR water
      info          TEXT,            -- eg. shop,postoffice
      notes         TEXT,            -- player notes
      x             INTEGER,
      y             INTEGER,
      z             INTEGER,
      date_added    DATE,            -- date added to database
      UNIQUE (uid)
    );

  CREATE INDEX IF NOT EXISTS info_index ON rooms (info);
  CREATE INDEX IF NOT EXISTS terrain_index ON rooms (terrain);
  CREATE INDEX IF NOT EXISTS area_index ON rooms (area);   
           
  CREATE TABLE exits (
      exitid      INTEGER PRIMARY KEY AUTOINCREMENT,
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     STRING  NOT NULL, -- exit from which room (in rooms table)
      touid       STRING  NOT NULL, -- exit to which room (in rooms table)
      date_added  DATE,             -- date added to database
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
    );
  CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
  CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
  
  DROP TABLE IF EXISTS rooms_lookup;
      
  CREATE VIRTUAL TABLE rooms_lookup USING FTS3(uid, name);
  ]])
  
  
  db:exec ("BEGIN TRANSACTION;") 
    
  for line in io.lines (filename) do
    
    local xml = string.match (line, "^%s*<(.-)/?>%s*$")
    
    if xml then
      local tag, things = string.match (xml, "^([%a/]+)%s*(.*)$")
      
      if tag then
        local f = handlers [tag]
        if f then
          local t = get_params (things)
          local problem = f (t)
          if problem then
            print ("Error (" .. problem .. ") processing XML:", xml)
          end -- if
        else
          print ("unprocessed line:", xml)
        end -- if tag not known
            
        count = count + 1
        
        else
          print ("No tag found on line:", xml)
        end -- if tag
      
      else
        print ("Line not processed:", line)
    end -- if xml
    
  end --  for each line
  
  db:exec ("COMMIT;") 
  
  print ("Found", count, "xml lines")
  print ("Found", areacount, "areas")
  print ("Found", roomcount, "rooms")
  print ("Found", endroomcount, "/rooms")
  print ("Found", coordcount, "coordinates")
  print ("Found", directioncount, "directions")
  print ("Found", environmentcount, "environments")

  OnPluginInstall()

end -- function create_map_database

]]>
</script>

</muclient>
