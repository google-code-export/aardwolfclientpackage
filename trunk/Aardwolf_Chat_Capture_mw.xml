<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- This plugin was originally made by Garrion and then Kerberus using all the code and ideas at http://www.gammon.com.au/forum/?id=9385 -->
<!-- Modifications made by the Aardwolf Community -->

<muclient>
    <plugin
    name="ChatWindow"
    author="Aardwolf Community"
    id="b555825a4a5700c35fa80780"
    language="Lua"
    purpose="Move chats to a miniwindow"
    date_written="2010-04-04"
    requires="4.40"
    version="1.0"
    save_state="y"
    >

</plugin>

<triggers>
    <trigger
    enabled="y"
    match="^{say}(?<msg>.*)"
    regexp="y"
    script="chats"
    omit_from_output="y"
    sequence="100"
    ></trigger>

    <trigger
    enabled="y"
    match="^{chan ch=(?<channel>\w+)}(?<msg>.*)"
    regexp="y"
    script="chats"
    omit_from_output="y"
    sequence="100"
    ></trigger>

    <trigger
    enabled="y"
    match="^{tell}(?<msg>.*)"
    script="chats"
    omit_from_output="y"
    regexp="y"
    sequence="100"
    ></trigger>
</triggers>

<aliases>
    <alias
    script="chat_echo"
    match="^chats echo( on| off)?$"
    enabled="y"
    regexp="y"
    sequence="100"
    ignore_case="y"
    ></alias>
</aliases>

<script>
<![CDATA[

require "movewindow"  -- load the movewindow.lua module
require "copytable"

WINDOW_COLUMNS = 80
WINDOW_LINES = 10
MAX_LINES = 10000 -- how many lines to store
FONT_NAME = "Dina"
FONT_SIZE = 8
SCROLL_BAR_WIDTH = 14
LEFT_MARGIN = 5
RIGHT_MARGIN = 5

date_format = "[%d %b %H:%M:%S] "        -- [30 Aug 13:29:49]   date and time 24 hour
--date_format = "[%d %b %I:%M:%S%p] "  -- [30 Aug 01:20:12PM]     date and time 12 hour
--date_format = "[%H:%M:%S] "          -- [13:29:08]          time 24 hour
--date_format = "[%X] "                  -- [1:22:06 PM]            time 12 hour

echo = true

-- colours
WINDOW_BACKGROUND_COLOUR = ColourNameToRGB ("black")
WINDOW_TEXT_COLOUR = ColourNameToRGB ("white")
SCROLL_BACKGROUND_COLOUR = ColourNameToRGB ("#E8E8E8")
SCROLL_BAR_COLOUR = ColourNameToRGB ("black")
WINDOW_BORDER_COLOUR = ColourNameToRGB ("blue")

-- offset of text from edge
TEXT_INSET = 5

-- where to store the chat line
lines = {}  -- table of recent chat lines


lineStart = 1
lineEnd = 1

-- pull in telnet option handling
dofile (GetPluginInfo (GetPluginID (), 20) .. "telnet_options.lua")
SBWin = GetPluginID()
WINDOW_WIDTH = ""
WINDOW_HEIGHT = ""
font_height = ""

function OnPluginInstall()
   -- install the window movement handler, get back the window position
    windowinfo = movewindow.install (SBWin, 6)  
    
    -- Dummy window to get font characteristics
    check (WindowCreate (SBWin, windowinfo.window_left, windowinfo.window_top, 1, 1, windowinfo.window_mode, windowinfo.window_flags, WINDOW_BACKGROUND_COLOUR) )
    check (WindowFont(SBWin, "font"..SBWin, FONT_NAME, FONT_SIZE))
    font_height = WindowFontInfo (SBWin, "font"..SBWin, 1) -  WindowFontInfo (SBWin, "font"..SBWin, 4) + 1
    font_width = WindowTextWidth (SBWin, "font"..SBWin, "W")

    -- window size in pixels
    WINDOW_WIDTH = font_width*WINDOW_COLUMNS
    WINDOW_HEIGHT = font_height*(WINDOW_LINES+1.5)
    wrap_column = ((WINDOW_WIDTH-SCROLL_BAR_WIDTH)-(RIGHT_MARGIN+LEFT_MARGIN))/font_width

    init()
    OnPluginEnable ()  -- do initialization stuff
end

function init()
    WindowCreate(SBWin, windowinfo.window_left, windowinfo.window_top, WINDOW_WIDTH, WINDOW_HEIGHT, windowinfo.window_mode, windowinfo.window_flags, WINDOW_BACKGROUND_COLOUR)
    WindowAddHotspot(SBWin, "upHotspot", WINDOW_WIDTH-SCROLL_BAR_WIDTH, 0, 0, 20, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "Scroll up", 1, 0)
    WindowAddHotspot(SBWin, "downHotspot", WINDOW_WIDTH-SCROLL_BAR_WIDTH, WINDOW_HEIGHT-20, 0, 0, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "Scroll down", 1, 0)
    WindowShow(SBWin, true)

    -- draw drag bar rectangle
    -- show border so we can see what we are doing
    WindowRectOp (SBWin, 1, 0, 0, 0, 0, WINDOW_BORDER_COLOUR)
    -- top half
    WindowGradient (SBWin, 0, 0, 0, font_height/2, 0x000000, ColourNameToRGB("darkblue"), 2) 
    -- bottom half
    WindowGradient (SBWin, 0, font_height/2, 0, font_height, ColourNameToRGB("darkblue"), 0x000000, 2)   

    -- Title
    WindowText(SBWin, "font"..SBWin, "COMMUNICATION", ((WINDOW_WIDTH-SCROLL_BAR_WIDTH)-(7.5*font_height))/2, 1, WINDOW_WIDTH-(RIGHT_MARGIN+SCROLL_BAR_WIDTH), 0, ColourNameToRGB("white"), false)
    
    -- scroll bar
    WindowRectOp(SBWin, 2, WINDOW_WIDTH-SCROLL_BAR_WIDTH, 0, 0, 0, SCROLL_BACKGROUND_COLOUR)
    WindowRectOp (SBWin, 1, WINDOW_WIDTH-SCROLL_BAR_WIDTH+1, 15, WINDOW_WIDTH-1, WINDOW_HEIGHT-15, SCROLL_BAR_COLOUR)
    WindowLine (SBWin, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, 3, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+1, 9, ColourNameToRGB ("black"), 0, 1)
    WindowLine (SBWin, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, 3, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+13, 9, ColourNameToRGB ("black"), 0, 1)

    WindowLine (SBWin, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, WINDOW_HEIGHT-3, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+1, WINDOW_HEIGHT-9, ColourNameToRGB ("black"), 0, 1)
    WindowLine (SBWin, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+7, WINDOW_HEIGHT-3, (WINDOW_WIDTH-SCROLL_BAR_WIDTH)+13, WINDOW_HEIGHT-9, ColourNameToRGB ("black"), 0, 1)

    -- add the drag handler so they can move the window around
    movewindow.add_drag_handler (SBWin, 0, 0, 0, font_height)    

    if #lines >= 1 then
        writeLines()
    end -- if
end

function OnPluginConnect ()
    -- first time after connect, get tags right
    TelnetOptionOn (TELOPT_CHANNELS)
    TelnetOptionOn (TELOPT_TELLS)
    TelnetOptionOn (TELOPT_SAYS)
end -- function OnPluginConnect

function OnPluginClose ()
    -- if enabled
    if GetPluginInfo (GetPluginID (), 17) then
        OnPluginDisable()
    end -- if enabled
end -- OnPluginClose

function OnPluginEnable ()
    WindowShow (SBWin, true)  
    -- if we are connected when the plugin loads, it must have been reloaded whilst playing
    if IsConnected () then
        OnPluginConnect ()
    end -- if already connected
end -- OnPluginEnable

function OnPluginSaveState ()
    -- save window current location for next time  
    SetVariable ("enabled", tostring (GetPluginInfo (GetPluginID (), 17)))
    movewindow.save_state (SBWin)
end -- function OnPluginSaveState

function OnPluginDisable ()
    TelnetOptionOff (TELOPT_CHANNELS)
    TelnetOptionOff (TELOPT_TELLS)
    TelnetOptionOff (TELOPT_SAYS)
    WindowShow( SBWin, false )
end -- function OnPluginSaveState

-- display one line
function Display_Line (line, styles)
    local left = TEXT_INSET
    for _, v in ipairs (styles) do
        left = left + WindowText (SBWin, "font"..SBWin, v.text, left, SPACING, 0, 0, v.textcolour)
    end -- for each style run
end -- Display_Line

-- display all visible lines
function writeLines()
    SPACING = (font_height + 1)
    for count = lineStart, lineEnd do
        Display_Line( count, lines[count] )
        SPACING = SPACING + (font_height + 1)
    end
end

-- clear and redraw
function refresh()
    WindowRectOp(SBWin, 2, 0, 0, 0, 0, WINDOW_BACKGROUND_COLOUR)
    init()
end

-- Main capture routine
function chats (name, line, wildcards, styles)
    local avail = 0
    local line_styles
    
    -- strip out the tag
    tag_length = string.find(styles[1].text,"}")
    styles[1].text = string.sub(styles[1].text, tag_length+1)
    styles[1].length = styles[1].length-tag_length
    
    -- echo in this world as well if the user wants
    if echo then
        for _, v in ipairs (styles) do
            ColourTell (RGBColourToName (v.textcolour),RGBColourToName (v.backcolour),v.text)
        end -- for each style run
        Note ("")  -- wrap up line
    end -- echo wanted

    -- inject timestamp
    tstamp = os.date (date_format)
    styles[1].text = tstamp..styles[1].text
    styles[1].length = styles[1].length+string.len(tstamp)
    
    -- keep pulling out styles and trying to fit them on the current line
    while #styles > 0 do
        if avail <= 0 then -- no room available? start new line
            -- remove first line if filled up
            if #lines >= MAX_LINES then
                table.remove (lines, 1)
            end -- if 
            avail = WINDOW_WIDTH - (TEXT_INSET * 2) - 9
            line_styles = {}
            add_line( line_styles )
        end -- line full

        -- get next style, work out how long it is
        local style = table.remove (styles, 1)
        local width = WindowTextWidth (SBWin, "font"..SBWin, style.text)

        -- if it fits, copy whole style in
        if width <= avail then
            table.insert (line_styles, style)
            avail = avail - width
        else -- otherwise, have to split style   
            -- look for trailing space (work backwards). remember where space is
            local col = style.length - 1
            local split_col
            -- keep going until out of columns
            while col > 1 do
                width = WindowTextWidth (SBWin, "font"..SBWin, style.text:sub (1, col)) 
                if width <= avail then
                    if not split_col then
                        split_col = col  -- in case no space found, this is where we can split
                    end -- if
                    -- see if space here
                    if style.text:sub (col, col) == " " then
                        split_col = col
                        break
                    end -- if space
                end -- if will now fit
                col = col - 1
            end -- while
          
            -- if we found a place to split, use old style, and make it shorter. Also make a copy and put the rest in that
            if split_col then
                table.insert (line_styles, style)
                local style_copy = copytable.shallow (style)
                style.text = style.text:sub (1, split_col)
                style.length = split_col 
                style_copy.text = style_copy.text:sub (split_col + 1)
                style_copy.length = #style_copy.text
                table.insert (styles, 1, style_copy)
            elseif next (line_styles) == nil then
                table.insert (line_styles, style)
            else
                table.insert (styles, 1, style)
            end -- if    
            avail = 0  -- now we need to wrap     
            
        end -- if could not fit whole thing in
    end -- while we still have styles over
    refresh( )
end -- chats

function add_line ( line )
    -- add new line
    table.insert (lines, line )

    -- advance the count
    if #lines >= WINDOW_LINES then
        lineStart = lineStart + 1
    end -- if
        
    if #lines > 1 then
        lineEnd = lineEnd + 1
    end -- if
end -- add_line

keepscrolling = false
require "wait"

function scrollbar(calledBy)
    wait.make (function()
        while keepscrolling == true do
            if calledBy == "upHotspot" then
                if (lineStart > 1) then
                    lineStart = lineStart - 1
                    lineEnd = lineEnd - 1
                end
            elseif calledBy == "downHotspot" then
                if (lineEnd < #lines) then
                    lineStart = lineStart + 1
                    lineEnd = lineEnd + 1
                end
            end
            refresh()
            wait.time(0.1)
        end
    end)
end

function MouseOver(flags, hotspot_id)
keepscrolling = false
end

function CancelMouseOver(flags, hotspot_id)
keepscrolling = false
end

function MouseDown(flags, hotspot_id)
    keepscrolling = true
    scrollbar(hotspot_id)
end

function CancelMouseDown(flags, hotspot_id)
keepscrolling = false
end

function MouseUp(flags, hotspot_id)
keepscrolling = false
end

function chat_echo (name, line, wildcards)
    if wildcards [1] == false then
        echo = not echo
    elseif wildcards [1]:lower () == " on" then
        echo = true
    elseif wildcards [1]:lower () == " off" then
        echo = false
    end -- if

    if echo then
        ColourNote ("yellow", "", "Echoing chats in main window enabled.")
    else
        ColourNote ("yellow", "", "Echoing chats in main window DISABLED.")
    end -- if
end -- chat_echo

]]>
</script>
</muclient>
